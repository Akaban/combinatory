from abc import ABCMeta, abstractmethod
from random import randint
from functools import lru_cache

CACHE_MAX_SIZE=50

class AbstractRule(metaclass=ABCMeta):

    def __init__(self, constant, valuation):
        self._grammar = {}
        self._constant = constant
        self._valuation = valuation

    def _set_grammar(self, gram):
        self._grammar = gram
        
    @property
    def valuation(self):
        return self._valuation
        
    @property
    def constant(self):
        return self._constant
    
    @abstractmethod
    def count(self, n):
        """count the numbers of objects of weight n that can be generated by the grammar"""
    
    @abstractmethod
    def list(self, n):
        """Enumerate objects of weight n that can be generated by the grammar and return them as a list"""
        
    @abstractmethod
    def unrank(self, n, rnk):
        """Return object of size n and rank rnk in the set generated by the grammar"""
    
    @abstractmethod
    def rank(self, obj):
        """ Return the rank of obj in the set generated by the grammar"""
        
    def random(self, n):
        """
        Return a random element of size n generated by the grammar
        """
        return self.unrank(n, randint(0, self.count(n)-1))

class ConstantRule(AbstractRule,metaclass=ABCMeta):
    def __init__(self, pyobj, valuation):
        super().__init__(True, valuation)
        self._object = pyobj

class ConstructorRule(AbstractRule,metaclass=ABCMeta):
    def __init__(self, value):
        super().__init__(False, float('inf'))
        self._parameters = value

    @abstractmethod
    def rankImplemented(self):
        """
        Return true if the functions needed by rank are implemented
        Return false otherwise
        """

    @property
    def rules(self):
        return tuple(map(lambda p : self._grammar[p], self._parameters))

    @abstractmethod
    def _calc_valuation(self):
        """update valuation"""


class UnionRule(ConstructorRule):
    def __init__(self, rule1, rule2, origin=None, objSize=None):
        super().__init__((rule1, rule2))
        self._origin=origin
        self._objSize=objSize

    def rankImplemented(self):
        return not (self._origin is None or self._objSize is None)
        
    def __repr__(self):
        return "UnionRule({},{})".format(self._parameters[0],self._parameters[1])
        
    def _calc_valuation(self):
        rule1, rule2 = self.rules
        valuation = min(rule1.valuation, rule2.valuation)
        self._valuation = valuation
        
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def count(self, n):
        rule1, rule2 = self.rules
        return rule1.count(n) + rule2.count(n)
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def list(self, n):
        rule1, rule2 = self.rules
        return rule1.list(n) + rule2.list(n)
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def unrank(self, n, rank):
        
        if rank >= self.count(n):
            raise ValueError("Error called unrank with a too big rank")
        
        rule1, rule2 = self.rules
        rule1count = rule1.count(n)
        
        if rank >= rule1count:
            return rule2.unrank(n, rank - rule1count)
        else:
            return rule1.unrank(n, rank)

    def rank(self, obj):

        if self._origin is None or self._objSize is None:
            raise ValueError("Origin function or objSize function is undefined, cannot continue.")

        rule1, rule2 = self.rules

        #print("Looking for origin of obj={}".format(obj))

        if self._origin(obj) == 0:
            return rule1.rank(obj) #obj originated from rule1
        else: #originated from rule2
            return rule1.count(self._objSize(obj)) + rule2.rank(obj) 


        
class ProductRule(ConstructorRule):
    def __init__(self, rule1, rule2, cons, uncons=None, objSize=None):
        super().__init__((rule1, rule2))
        self._cons = cons
        self._uncons = uncons
        self._objSize = objSize

    def rankImplemented(self):
        return not (self._uncons is None or self._objSize is None)
     
    
    def __repr__(self):
        return "ProductRule({},{})".format(self._parameters[0],self._parameters[1])
        
    def _calc_valuation(self):
        rule1, rule2 = self.rules
        valuation = rule1.valuation + rule2.valuation
        self._valuation = valuation
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def count(self, n):
        rule1, rule2 = self.rules
        countsum=0
        for i in range(n + 1):
            k=n-i
            if rule1.valuation > i or rule2.valuation > k: 
                continue #Si cette condition est satisfaite alors
                         # rule1.count(i)*rule2.count(k) = 0 donc on passe
            countsum += rule1.count(i) * rule2.count(k)
        return countsum
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def list(self, n):
        rule1, rule2 = self.rules
        res=[]
        
        for i in range(n+1):
            k=n-i
            if rule1.valuation > i or rule2.valuation > k:
                continue
            for el1 in rule1.list(i):
                for el2 in rule2.list(k):
                    res.append(self._cons(el1,el2))
        return res
    
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def unrank(self, n, rank):
        if rank >= self.count(n):
            raise ValueError("Error called unrank with a too big rank")
            
        rule1, rule2 = self.rules 
        count, prec_count, i = 0, 0, 0
        #on compte les éléments de la grammaire pour chaque i jusqu'a 
        #ce qu'on en aie plus que le rang souhaité 
        while count <= rank:
            k = n - i
            prec_count=count
            count += rule1.count(i) * rule2.count(k)
            i += 1    
        i-=1
        j = rank - prec_count #le rang j est exactement le rang souhaité
        k = rule2.count(n-i)  # moins l'avant dernier comptage de notre boucle
        q, r = j // k, j % k
        
        return self._cons(rule1.unrank(i, q), rule2.unrank(n-i, r))

    def rank(self, obj):

        if self._uncons is None or self._objSize is None:
            raise ValueError("Uncons function or objSize function is undefined, cannot continue.")

        rule1, rule2 = self.rules

        n = self._objSize(obj)
        #print("Trying to unpack: {}".format(obj))
        obj1, obj2 = self._uncons(obj)

        rank_obj1 = rule1.rank(obj1)
        rank_obj2 = rule2.rank(obj2)

        size_obj1 = self._objSize(obj1)

        count_before = 0 #Le nombre d'éléments avec un obj1 inférieur au nôtre

        for i in range(size_obj1):
            count_before += rule1.count(i) * rule2.count(n-i)

        #À ce comptage on rajoute le rang d'obj1 * le nombre d'éléments dans
        # rule2 de taille (n - size_obj1) = size_obj2


        return count_before + rank_obj2 + rank_obj1 * rule2.count(n - size_obj1) 

#Syntaxe: Sequence(NonTerm, CasVide, cons, ...)
class SequenceRule(ConstructorRule):

    def __init__(self, rule1, rule2, cons, uncons=None, objSize=None):
        super().__init__((rule1, rule2))
        self._cons = cons
        self._uncons = uncons
        self._objSize = objSize

    def __repr__(self):
        return "SequenceRule({},{})".format(self._parameters[0], self._parameters[1])


    def rankImplemented(self):
        return not (self._uncons is None or self._objSize is None)


    def _calc_valuation(self):
        self._valuation = 0 #Le plus petit objet est un EpsilonRule = 0

    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def count(self, n):

        if n==0: #casVide
            return 1

        nonterm, vide = self.rules

        countsum=0
        for i in range (n+1):
            k=n-i
            if nonterm.valuation > i:
                continue
            countsum += nonterm.count(i) * self.count(k)
        return countsum

    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def list(self, n):

        nonterm, vide = self.rules

        if n==0:
            return vide.list(n)

        res=[]

        for i in range(n+1):
            k=n-i
            if nonterm.valuation > k :
                continue
            for el1 in self.list(i):
                for el2 in nonterm.list(k):
                    res.append(self._cons(el1, el2))
        return res

    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def unrank(self, n, rank):

        if rank >= self.count(n):
            raise ValueError("Error called unrank with a too big rank")

        nonterm, vide = self.rules

        if n==0:
            return vide.unrank(n, rank)

           
        count, prec_count, i = 0, 0, 0
        while count <= rank:
            k = n - i
            prec_count=count
            count += nonterm.count(i) * self.count(k)
            i += 1    
        i-=1
        j = rank - prec_count 
        k = self.count(n-i)
        q, r = j // k, j % k

        
        return self._cons(nonterm.unrank(i, q), self.unrank(n-i, r))


    def rank(self, obj):

        nonterm, vide = self.rules
        if obj == vide._object:
            return 0

        if self._uncons is None or self._objSize is None:
            raise ValueError("Uncons function or objSize function is undefined, cannot continue.")


        n = self._objSize(obj)
        obj1, obj2 = self._uncons(obj)

        rank_obj1 = nonterm.rank(obj1)
        rank_obj2 = self.rank(obj2)

        size_obj1 = self._objSize(obj1)

        count_before = 0 #Le nombre d'éléments avec un obj1 inférieur au nôtre

        for i in range(size_obj1):
            count_before += nonterm.count(i) * self.count(n-i)

        #À ce comptage on rajoute le rang d'obj1 * le nombre d'éléments dans
        # rule2 de taille [(n - size_obj1) = size_obj2]


        return count_before + rank_obj2 + rank_obj1 * self.count(n - size_obj1)


class BoundRule(ConstructorRule):

    def __init__(self, rule, lower_bound, upper_bound):

        if lower_bound > upper_bound:
            raise ValueError("lower_bound={} has to be less than upper_bound={}.".format(lower_bound, upper_bound))

        self._lb = lower_bound
        self._ub = upper_bound
        self._rule = rule


    def rankImplemented(self):
        return True


    def __repr__(self):
        return "BoundRule({}, {}, {})".format(self._rule, self._lb, self._ub)

    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def count(self, n):
        count=0
        for i in range(self._lb, self._ub+1):
            count += self._rule.count(i)
        return count

    def list(self, n):
        ret=[]
        for i in range(self._lb, self._ub+1):
            ret += self._rule.list(i)
        return ret

    def unrank(self, rank):
        
        count, i=0, self._lb
        prec_count=0
        while count <= rank:
            prec_count=count
            count += self._rule.count(i)
            i+=1
            if i > self._ub:
                raise ValueError("called unrank with a too big rank")
        return self._rule.unrank(i-1, rank - prec_count)
     

    def rank(self, obj):
        ret=0

        if isinstance(self._rule, ConstantRule):
            return self._rule.unrank(obj)

        if self._rule._objSize is None:
            raise ValueError("{} has not defined objSize".format(self._rule))


        objSize = self._rule._objSize

        for i in range(self._lb, objSize(obj)):
            ret += self._rule.count(i)

        return ret + self._rule.rank(obj)

    def _calc_valuation(self):
        self._valuation=self._lb


class EpsilonRule(ConstantRule):
    def __init__(self,obj):
        super().__init__(obj, 0)
        
    def __repr__(self):
        return "EpsilonRule({})".format(self._object)
        
    def count(self, n):
        return 1 if n==0 else 0
    
    def list(self, n):
        return [self._object] if n==0 else []
    
    def unrank(self, n, rank):
        if n==0 and rank==0:
            return self._object
        raise ValueError("Called unrank on EpsilonRule with wrong args{}".format(n,rank))

    def rank(self, obj):
        if obj==self._object:
            return 0
        raise ValueError("Called rank on EpsilonRule constant with wrong obj={}".format(obj))
        
class SingletonRule(ConstantRule):
    def __init__(self,obj):
        super().__init__(obj, 1)
        
    def __repr__(self):
        return "SingletonRule({})".format(self._object)
        
    def count(self, n):
        return 1 if n==1 else 0
    
    def list(self, n):
        return [self._object] if n==1 else []
    
    def unrank(self, n, rank):
        if n==1 and rank==0:
            return self._object
        raise ValueError("Called unrank on SingletonRule constant with wrong args {}".format((n,rank)))

    def rank(self, obj):
        if obj==self._object:
            return 0
        raise ValueError("Called rank on SingletonRule constant with wrong obj={}".format(obj))


def init_grammar(gram):
    
    for rule in gram.values():
        if (not rule.constant):
            for pr in rule._parameters :
                if pr not in gram:
                    raise ValueError("A rule of the grammar ("+pr+") does not exist")
                
        rule._set_grammar(gram)
        
    valuation = [rule.valuation for rule in gram.values()]
    valuation_old = [float('inf') for _ in valuation]

    #algorithme de point fixe
    while (valuation != valuation_old):
        valuation_old = valuation
        for k, v in gram.items():
            if not v.constant:
                v._calc_valuation()
        valuation = [rule.valuation for rule in gram.values()]
        
    if float('inf') in valuation:
        inf_rules = [ k for k, v in gram.items() if v.valuation == float('inf')]
        raise ValueError("The grammar is incorrect, there is a rule that yields no terminal : {}".format(inf_rules))
                
    return "Valuation = {}".format({k : v.valuation for k,v in gram.items()})

class Union:
    
    def __init__(self, rule1, rule2):
        self._rule1 = rule1
        self._rule2 = rule2

    def __repr__(self):
        return "Union({},{})".format(self._rule1, self._rule2)
    
    def expand(self, gram, keyBefore=None):
        
        rule1, rule2 = self._rule1, self._rule2
        rule1_expand, rule2_expand = rule1.expand(gram), rule2.expand(gram)
        key = keyBefore or "Union_{}_{}".format(rule1_expand, rule2_expand)

        gram[key] = UnionRule(rule1_expand, rule2_expand)
        return key
        
class Prod:
    
    def __init__(self, rule1, rule2, cons):
        self._rule1 = rule1
        self._rule2 = rule2
        self._cons = cons
    
    def __repr__(self):
        return "Prod({},{})".format(self._rule1, self._rule2)
    
    def expand(self, gram, keyBefore=None):
        
        rule1, rule2 = self._rule1, self._rule2
        
        rule1_expand, rule2_expand = rule1.expand(gram), rule2.expand(gram)
        key = keyBefore or "Prod_{}_{}".format(rule1_expand, rule2_expand)

        gram[key] = ProductRule(rule1_expand, rule2_expand, self._cons)
        return key
    
class Singleton:
    
    def __init__(self, obj):
        self._obj = obj
        
    def __repr__(self):
        return "Singleton({})".format(self._obj)
    
    def expand(self, gram, keyBefore=None):
        
        key=keyBefore or "Sing_{}".format(self._obj)
        gram[key] = SingletonRule(self._obj)
        return key
        
class Epsilon:
    
    def __init__(self, obj):
        self._obj = obj
        
    def __repr__(self):
        return "Epsilon({})".format(self._obj)
    
    def expand(self, gram, keyBefore=None):
        
        key= keyBefore or "Epsi_{}".format(self._obj)
        gram[key] = EpsilonRule(self._obj)
        
class NonTerm:
    
    def __init__(self, rule):
        self._rule = rule
        
    def __repr__(self):
        return "nonTerm({})".format(self._rule)
    
    def expand(self, gram, keyBefore=None):    
        return self._rule
    
class Sequence:

    def __init__(self, nonterm, ruleVide):
        self._nonterm = nonterm
        self._ruleVide = ruleVide

    def __repr__(self):
        return "Sequence({},{})".format(self._rule, self._ruleVide)

    def expand(self, gram, keyBefore=None):

        if self._nonterm not in gram:
            raise ValueError("The non-terminal {} is not in the grammar.".format(self._nonterm))

        rule, ruleVide = self._rule, self._ruleVide
        ruleVide_expand = ruleVide.expand(gram)

        key=keyBefore or "Seq_{}_0".format(rule)
        prodKey = "_prod" + key


        gram[prodKey] = ProductRule(key, self._nonterm)
        gram[key] = UnionRule(ruleVide_expand, prodKey)




    
def expand_init_grammar(gram):
    
    assoc = {}
    expandedGram = {}
    
    rules = list(gram.items())
    for ruleName, rule in rules:
        rule.expand(expandedGram, ruleName)
    init_grammar(expandedGram)
    return expandedGram
