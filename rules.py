from abc import ABCMeta, abstractmethod
from random import randint
from functools import lru_cache

CACHE_MAX_SIZE=50

class AbstractRule(metaclass=ABCMeta):

    def __init__(self, constant, valuation):
        self._grammar = {}
        self._constant = constant
        self._valuation = valuation

    def _set_grammar(self, gram):
        self._grammar = gram
        
    @property
    def valuation(self):
        return self._valuation
        
    @property
    def constant(self):
        return self._constant
    
    @abstractmethod
    def count(self, n):
        """count the numbers of objects of weight n that can be generated by the grammar"""
    
    @abstractmethod
    def list(self, n):
        """Enumerate objects of weight n that can be generated by the grammar and return them as a list"""
        
    @abstractmethod
    def unrank(self, n, rank):
        """Return object of size n and rank rank in the set generated by the grammar"""
        
    def random(self, n):
        """
        Return a random element of size n generated by the grammar
        """
        return self.unrank(n, randint(0, self.count(n)-1))

class ConstantRule(AbstractRule,metaclass=ABCMeta):
    def __init__(self, pyobj, valuation):
        super().__init__(True, valuation)
        self._object = pyobj


class ConstructorRule(AbstractRule,metaclass=ABCMeta):
    def __init__(self, value):
        super().__init__(False, float('inf'))
        self._parameters = value

    @property
    def rules(self):
        return tuple(map(lambda p : self._grammar[p], self._parameters))

    @abstractmethod
    def _calc_valuation(self):
        """update valuation"""


class UnionRule(ConstructorRule):
    def __init__(self, rule1, rule2):
        super().__init__((rule1, rule2))
        
    def __repr__(self):
        return "UnionRule({},{})".format(self._parameters[0],self._parameters[1])
        
    def _calc_valuation(self):
        rule1, rule2 = self.rules
        valuation = min(rule1.valuation, rule2.valuation)
        self._valuation = valuation
        
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def count(self, n):
        rule1, rule2 = self.rules
        return rule1.count(n) + rule2.count(n)
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def list(self, n):
        rule1, rule2 = self.rules
        return rule1.list(n) + rule2.list(n)
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def unrank(self, n, rank):
        
        if rank >= self.count(n):
            raise ValueError("Error called unrank with a too big rank")
        
        rule1, rule2 = self.rules
        rule1count = rule1.count(n)
        
        if rank >= rule1count:
            return rule2.unrank(n, rank - rule1count)
        else:
            return rule1.unrank(n, rank)
            

        
class ProductRule(ConstructorRule):
    def __init__(self, rule1, rule2, cons):
        super().__init__((rule1, rule2))
        self._cons = cons
    
    def __repr__(self):
        return "ProductRule({},{})".format(self._parameters[0],self._parameters[1])
        
    def _calc_valuation(self):
        rule1, rule2 = self.rules
        valuation = rule1.valuation + rule2.valuation
        self._valuation = valuation
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def count(self, n):
        rule1, rule2 = self.rules
        countsum=0
        for i in range(n + 1):
            k=n-i
            if rule1.valuation > i or rule2.valuation > k: 
                continue #Si cette condition est satisfaite alors
                         # rule1.count(i)*rule2.count(k) = 0 donc on passe
            countsum += rule1.count(i) * rule2.count(k)
        return countsum
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def list(self, n):
        rule1, rule2 = self.rules
        res=[]
        
        for i in range(n+1):
            k=n-i
            if rule1.valuation > i or rule2.valuation > k:
                continue
            for el1 in rule1.list(i):
                for el2 in rule2.list(k):
                    res.append(self._cons(el1,el2))
        return res
    
    
    @lru_cache(maxsize=CACHE_MAX_SIZE)
    def unrank(self, n, rank):
        if rank >= self.count(n):
            raise ValueError("Error called unrank with a too big rank")
            
        rule1, rule2 = self.rules 
        count, prec_count, i = 0, 0, 0
        #on compte les éléments de la grammaire pour chaque i jusqu'a 
        #ce qu'on en aie plus que le rang souhaité 
        while count <= rank:
            k = n - i
            prec_count=count
            count += rule1.count(i) * rule2.count(k)
            i += 1    
        i-=1
        j = rank - prec_count #le rang j est exactement le rang souhaité
        k = rule2.count(n-i)  # moins l'avant dernier comptage de notre boucle
        q, r = j // k, j % k
        
        return self._cons(rule1.unrank(i, q), rule2.unrank(n-i, r))
    
class EpsilonRule(ConstantRule):
    def __init__(self,obj):
        super().__init__(obj, 0)
        
    def __repr__(self):
        return "EpsilonRule({})".format(self._object)
        
    def count(self, n):
        return 1 if n==0 else 0
    
    def list(self, n):
        return [self._object] if n==0 else []
    
    def unrank(self, n, rank):
        if n==0 and rank==0:
            return self._object
        raise ValueError("Called unrank on EpsilonRule with wrong args{}".format(n,rank))
        
class SingletonRule(ConstantRule):
    def __init__(self,obj):
        super().__init__(obj, 1)
        
    def __repr__(self):
        return "SingletonRule({})".format(self._object)
        
    def count(self, n):
        return 1 if n==1 else 0
    
    def list(self, n):
        return [self._object] if n==1 else []
    
    def unrank(self, n, rank):
        if n==1 and rank==0:
            return self._object
        raise ValueError("Called unrank on SingletonRule constant with wrong args {}".format((n,rank)))



def init_grammar(gram):
    
    for rule in gram.values():
        if (not rule.constant):
            for pr in rule._parameters :
                if pr not in gram:
                    raise ValueError("A rule of the grammar ("+pr+") does not exist")
                
        rule._set_grammar(gram)
        
    valuation = [rule.valuation for rule in gram.values()]
    valuation_old = [float('inf') for _ in valuation]

    #algorithme de point fixe
    while (valuation != valuation_old):
        valuation_old = valuation
        for k, v in gram.items():
            if not v.constant:
                v._calc_valuation()
        valuation = [rule.valuation for rule in gram.values()]
        
    if float('inf') in valuation:
        inf_rules = [ k for k, v in gram.items() if v.valuation == float('inf')]
        raise ValueError("The grammar is incorrect, there is a rule that yields no terminal : {}".format(inf_rules))
                
    return "Valuation = {}".format({k : v.valuation for k,v in gram.items()})

class Union:
    
    def __init__(self, rule1, rule2):
        self._rule1 = rule1
        self._rule2 = rule2

    def __repr__(self):
        return "Union({},{})".format(self._rule1, self._rule2)
    
    def expand(self, gram, keyBefore=None):
        
        rule1, rule2 = self._rule1, self._rule2
        rule1_expand, rule2_expand = rule1.expand(gram), rule2.expand(gram)
        key = keyBefore or "Union_{}_{}".format(rule1_expand, rule2_expand)

        gram[key] = UnionRule(rule1_expand, rule2_expand)
        return key
        
class Prod:
    
    def __init__(self, rule1, rule2, cons):
        self._rule1 = rule1
        self._rule2 = rule2
        self._cons = cons
    
    def __repr__(self):
        return "Prod({},{})".format(self._rule1, self._rule2)
    
    def expand(self, gram, keyBefore=None):
        
        rule1, rule2 = self._rule1, self._rule2
        
        rule1_expand, rule2_expand = rule1.expand(gram), rule2.expand(gram)
        key = keyBefore or "Prod_{}_{}".format(rule1_expand, rule2_expand)

        gram[key] = UnionRule(rule1_expand, rule2_expand)
        return key
    
class Singleton:
    
    def __init__(self, obj):
        self._obj = obj
        
    def __repr__(self):
        return "Singleton({})".format(self._obj)
    
    def expand(self, gram, keyBefore=None):
        
        key=keyBefore or "Sing_{}".format(self._obj)
        gram[key] = SingletonRule(self._obj)
        return key
        
class Epsilon:
    
    def __init__(self, obj):
        self._obj = obj
        
    def __repr__(self):
        return "Epsilon({})".format(self._obj)
    
    def expand(self, gram, keyBefore=None):
        
        key= keyBefore or "Epsi_{}".format(self._obj)
        gram[key] = EpsilonRule(self._obj)
        
class NonTerm:
    
    def __init__(self, rule):
        self._rule = rule
        
    def __repr__(self):
        return "nonTerm({})".format(self._rule)
    
    def expand(self, gram, keyBefore=None):    
        return self._rule
        
    
def expand_init_grammar(gram):
    
    assoc = {}
    expandedGram = {}
    
    rules = list(gram.items())
    for ruleName, rule in rules:
        rule.expand(expandedGram, ruleName)
    init_grammar(expandedGram)
    return expandedGram
